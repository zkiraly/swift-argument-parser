{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When creating commands, you can define three primary kinds of command-line inputs:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Arguments"}]},{"type":"text","text":" are values given by a user and are read in order from first to last. For example, this command is called with three file names as arguments:"}]},{"type":"codeListing","syntax":null,"code":["% example file1.swift file2.swift file3.swift"]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Options"}]},{"type":"text","text":" are named key-value pairs. Keys start with one or two dashes ("},{"type":"codeVoice","code":"-"},{"type":"text","text":" or "},{"type":"codeVoice","code":"--"},{"type":"text","text":"), and a user can separate the key and value with an equal sign ("},{"type":"codeVoice","code":"="},{"type":"text","text":") or a space. This command is called with two options:"}]},{"type":"codeListing","syntax":null,"code":["% example --count=5 --index 2"]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"emphasis","inlineContent":[{"type":"text","text":"Flags"}]},{"type":"text","text":" are like options, but without a paired value. Instead, their presence indicates a particular value (usually "},{"type":"codeVoice","code":"true"},{"type":"text","text":"). This command is called with two flags:"}]},{"type":"codeListing","syntax":null,"code":["% example --verbose --strip-whitespace"]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The three preceding examples could be calls of this "},{"type":"codeVoice","code":"Example"},{"type":"text","text":" command:"}]},{"type":"codeListing","syntax":"swift","code":["struct Example: ParsableCommand {","    @Argument var files: [String] = []","    @Option var count: Int?","    @Option var index = 0","    @Flag var verbose = false","    @Flag var stripWhitespace = false","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This example shows how "},{"type":"codeVoice","code":"ArgumentParser"},{"type":"text","text":" provides defaults that speed up your initial development process:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Option and flag names are derived from the names of your command’s properties."}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"What kinds of inputs are valid, and whether arguments are required, is based on your properties’ types and default values."}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example, all of the properties have default values (optional properties default to "},{"type":"codeVoice","code":"nil"},{"type":"text","text":")."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Users must provide values for all properties with no implicit or specified default. For example, this command would require one integer argument and a string with the key "},{"type":"codeVoice","code":"--user-name"},{"type":"text","text":"."}]},{"type":"codeListing","syntax":"swift","code":["struct Example: ParsableCommand {","    @Option var userName: String","    @Argument var value: Int","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When called without both values, the command exits with an error:"}]},{"type":"codeListing","syntax":null,"code":["% example 5","Error: Missing '--user-name <user-name>'","Usage: example --user-name <user-name> <value>","  See 'example --help' for more information.","% example --user-name kjohnson","Error: Missing '<value>'","Usage: example --user-name <user-name> <value>","  See 'example --help' for more information."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When providing a default value for an array property, any user-supplied values replace the entire default."}]},{"type":"codeListing","syntax":"swift","code":["struct Lucky: ParsableCommand {","  @Argument var numbers = [7, 14, 21]","","  mutating func run() throws {","    print(\"\"\"","    Your lucky numbers are:","    \\(numbers.map(String.init).joined(separator: \" \"))","    \"\"\")","  }","}"]},{"type":"codeListing","syntax":null,"code":["% lucky ","Your lucky numbers are:","7 14 21","% lucky 1 2 3","Your lucky numbers are:","1 2 3"]},{"anchor":"Customizing-option-and-flag-names","level":2,"type":"heading","text":"Customizing option and flag names"},{"type":"paragraph","inlineContent":[{"type":"text","text":"By default, options and flags derive the name that you use on the command line from the name of the property, such as "},{"type":"codeVoice","code":"--count"},{"type":"text","text":" and "},{"type":"codeVoice","code":"--index"},{"type":"text","text":". Camel-case names are converted to lowercase with hyphen-separated words, like "},{"type":"codeVoice","code":"--strip-whitespace"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can override this default by specifying one or more name specifications in the "},{"type":"codeVoice","code":"@Option"},{"type":"text","text":" or "},{"type":"codeVoice","code":"@Flag"},{"type":"text","text":" initializers. This command demonstrates the four name specifications:"}]},{"type":"codeListing","syntax":"swift","code":["struct Example: ParsableCommand {","    @Flag(name: .long)  \/\/ Same as the default","    var stripWhitespace = false","","    @Flag(name: .short)","    var verbose = false","","    @Option(name: .customLong(\"count\"))","    var iterationCount: Int","","    @Option(name: [.customShort(\"I\"), .long])","    var inputFile: String","}"]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Specifying "},{"type":"codeVoice","code":".long"},{"type":"text","text":" or "},{"type":"codeVoice","code":".short"},{"type":"text","text":" uses the property’s name as the source of the command-line name. Long names use the whole name, prefixed by two dashes, while short names are a single character prefixed by a single dash. In this example, the "},{"type":"codeVoice","code":"stripWhitespace"},{"type":"text","text":" and "},{"type":"codeVoice","code":"verbose"},{"type":"text","text":" flags are specified in this way:"}]},{"type":"codeListing","syntax":null,"code":["% example --strip-whitespace -v"]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Specifying "},{"type":"codeVoice","code":".customLong(_:)"},{"type":"text","text":" or "},{"type":"codeVoice","code":".customShort(_:)"},{"type":"text","text":" uses the given string or character as the long or short name for the property."}]},{"type":"codeListing","syntax":null,"code":["% example --count 10 -I file1.swift"]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"text","text":"Use array literal syntax to specify multiple names. The "},{"type":"codeVoice","code":"inputFile"},{"type":"text","text":" property can alternatively be given with the default long name:"}]},{"type":"codeListing","syntax":null,"code":["% example --input-file file1.swift"]}]}]},{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Note:"}]},{"type":"text","text":" You can also pass "},{"type":"codeVoice","code":"withSingleDash: true"},{"type":"text","text":" to "},{"type":"codeVoice","code":".customLong"},{"type":"text","text":" to create a single-dash flag or option, such as "},{"type":"codeVoice","code":"-verbose"},{"type":"text","text":". Use this name specification only when necessary, such as when migrating a legacy command-line interface. Using long names with a single-dash prefix can lead to ambiguity with combined short names: it may not be obvious whether "},{"type":"codeVoice","code":"-file"},{"type":"text","text":" is a single option or the combination of the four short options "},{"type":"codeVoice","code":"-f"},{"type":"text","text":", "},{"type":"codeVoice","code":"-i"},{"type":"text","text":", "},{"type":"codeVoice","code":"-l"},{"type":"text","text":", and "},{"type":"codeVoice","code":"-e"},{"type":"text","text":"."}]},{"anchor":"Parsing-custom-types","level":2,"type":"heading","text":"Parsing custom types"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Arguments and options can be parsed from any type that conforms to the "},{"type":"codeVoice","code":"ExpressibleByArgument"},{"type":"text","text":" protocol. Standard library integer and floating-point types, strings, and Booleans all conform to "},{"type":"codeVoice","code":"ExpressibleByArgument"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can make your own custom types conform to "},{"type":"codeVoice","code":"ExpressibleByArgument"},{"type":"text","text":" by implementing "},{"type":"codeVoice","code":"init?(argument:)"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["struct Path: ExpressibleByArgument {","    var pathString: String","","    init?(argument: String) {","        self.pathString = argument","    }","}","","struct Example: ParsableCommand {","    @Argument var inputFile: Path","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The library provides a default implementation for "},{"type":"codeVoice","code":"RawRepresentable"},{"type":"text","text":" types, like string-backed enumerations, so you only need to declare conformance."}]},{"type":"codeListing","syntax":"swift","code":["enum ReleaseMode: String, ExpressibleByArgument {","    case debug, release","}","","struct Example: ParsableCommand {","    @Option var mode: ReleaseMode","","    mutating func run() throws {","        print(mode)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The user can provide the raw values on the command line, which are then converted to your custom type. Only valid values are allowed:"}]},{"type":"codeListing","syntax":null,"code":["% example --mode release","release","% example --mode future","Error: The value 'future' is invalid for '--mode <mode>'"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To use a non-"},{"type":"codeVoice","code":"ExpressibleByArgument"},{"type":"text","text":" type for an argument or option, you can instead provide a throwing "},{"type":"codeVoice","code":"transform"},{"type":"text","text":" function that converts the parsed string to your desired type. This is a good idea for custom types that are more complex than a "},{"type":"codeVoice","code":"RawRepresentable"},{"type":"text","text":" type, or for types you don’t define yourself."}]},{"type":"codeListing","syntax":"swift","code":["enum Format {","    case text","    case other(String)","","    init(_ string: String) throws {","        if string == \"text\" {","            self = .text","        } else {","            self = .other(string)","        }","    }","}","","struct Example: ParsableCommand {","    @Argument(transform: Format.init)","    var format: Format","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Throw an error from the "},{"type":"codeVoice","code":"transform"},{"type":"text","text":" function to indicate that the user provided an invalid value for that type. See "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Validation"},{"type":"text","text":" for more about customizing "},{"type":"codeVoice","code":"transform"},{"type":"text","text":" function errors."}]},{"anchor":"Using-flag-inversions,-enumerations,-and-counts","level":2,"type":"heading","text":"Using flag inversions, enumerations, and counts"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Flags are most frequently used for "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" properties. You can generate a "},{"type":"codeVoice","code":"true"},{"type":"text","text":"\/"},{"type":"codeVoice","code":"false"},{"type":"text","text":" pair of flags by specifying a flag inversion:"}]},{"type":"codeListing","syntax":"swift","code":["struct Example: ParsableCommand {","    @Flag(inversion: .prefixedNo)","    var index = true","","    @Flag(inversion: .prefixedEnableDisable)","    var requiredElement: Bool","","    mutating func run() throws {","        print(index, requiredElement)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When declaring a flag with an inversion, set the default by specifying "},{"type":"codeVoice","code":"true"},{"type":"text","text":" or "},{"type":"codeVoice","code":"false"},{"type":"text","text":" as the property’s initial value. If you want to require that the user specify one of the two inversions, leave off the default value."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the "},{"type":"codeVoice","code":"Example"},{"type":"text","text":" command defined above, a flag is required for the "},{"type":"codeVoice","code":"requiredElement"},{"type":"text","text":" property. The specified prefixes are prepended to the long names for the flags:"}]},{"type":"codeListing","syntax":null,"code":["% example --enable-required-element","true true","% example --no-index --disable-required-element","false false","% example --index","Error: Missing one of: '--enable-required-element', '--disable-required-element'"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"To create a flag with custom names for a Boolean value, to provide an exclusive choice between more than two names, or for collecting multiple values from a set of defined choices, define an enumeration that conforms to the "},{"type":"codeVoice","code":"EnumerableFlag"},{"type":"text","text":" protocol."}]},{"type":"codeListing","syntax":"swift","code":["enum CacheMethod: String, EnumerableFlag {","    case inMemoryCache","    case persistentCache","}","","enum Color: String, EnumerableFlag {","    case pink, purple, silver","}","","struct Example: ParsableCommand {","    @Flag var cacheMethod: CacheMethod","    @Flag var colors: [Color] = []","","    mutating func run() throws {","        print(cacheMethod)","        print(colors)","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The flag names in this case are drawn from the raw values — for information about customizing the names and help text, see the  "},{"type":"reference","isActive":true,"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/EnumerableFlag"},{"type":"text","text":" documentation."}]},{"type":"codeListing","syntax":null,"code":["% example --in-memory-cache --pink --silver",".inMemoryCache","[.pink, .silver]","% example","Error: Missing one of: '--in-memory-cache', '--persistent-cache'"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, when a flag is of type "},{"type":"codeVoice","code":"Int"},{"type":"text","text":", the value is parsed as a count of the number of times that the flag is specified."}]},{"type":"codeListing","syntax":"swift","code":["struct Example: ParsableCommand {","    @Flag(name: .shortAndLong)","    var verbose: Int","","    mutating func run() throws {","        print(\"Verbosity level: \\(verbose)\")","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this example, "},{"type":"codeVoice","code":"verbose"},{"type":"text","text":" defaults to zero, and counts the number of times that "},{"type":"codeVoice","code":"-v"},{"type":"text","text":" or "},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":" is given."}]},{"type":"codeListing","syntax":null,"code":["% example --verbose","Verbosity level: 1","% example -vvvv","Verbosity level: 4"]},{"anchor":"Specifying-default-values","level":2,"type":"heading","text":"Specifying default values"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can specify default values for almost all supported argument, option, and flag types using normal property initialization syntax:"}]},{"type":"codeListing","syntax":"swift","code":["enum CustomFlag: String, EnumerableFlag {","    case foo, bar, baz","}","","struct Example: ParsableCommand {","    @Flag","    var booleanFlag = false","","    @Flag","    var arrayFlag: [CustomFlag] = [.foo, .baz]","","    @Option","    var singleOption = 0","","    @Option","    var arrayOption = [\"bar\", \"qux\"]","","    @Argument","    var singleArgument = \"quux\"","","    @Argument","    var arrayArgument = [\"quux\", \"quuz\"]","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This includes all of the variants of the argument types above (including "},{"type":"codeVoice","code":"@Option(transform: ...)"},{"type":"text","text":", etc.), with a few notable exceptions:"}]},{"type":"unorderedList","items":[{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Optional"},{"type":"text","text":"-typed values (which default to "},{"type":"codeVoice","code":"nil"},{"type":"text","text":" and for which a default would not make sense, as the value could never be "},{"type":"codeVoice","code":"nil"},{"type":"text","text":")"}]}]},{"content":[{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Int"},{"type":"text","text":" flags (which are used for counting the number of times a flag is specified and therefore default to "},{"type":"codeVoice","code":"0"},{"type":"text","text":")"}]}]}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"If a default is not specified, the user must provide a value for that argument\/option\/flag or will receive an error that the value is missing."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You must also always specify a default of "},{"type":"codeVoice","code":"false"},{"type":"text","text":" for a non-optional "},{"type":"codeVoice","code":"Bool"},{"type":"text","text":" flag, as in the example above. This makes the behavior consistent with both normal Swift properties (which either must be explicitly initialized or optional to initialize a "},{"type":"codeVoice","code":"struct"},{"type":"text","text":"\/"},{"type":"codeVoice","code":"class"},{"type":"text","text":" containing them) and the other property types."}]},{"anchor":"Specifying-a-parsing-strategy","level":2,"type":"heading","text":"Specifying a parsing strategy"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When parsing a list of command-line inputs, "},{"type":"codeVoice","code":"ArgumentParser"},{"type":"text","text":" distinguishes between dash-prefixed keys and un-prefixed values. When looking for the value for a key, only an un-prefixed value will be selected by default."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"For example, this command defines a "},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":" flag, a "},{"type":"codeVoice","code":"--name"},{"type":"text","text":" option, and an optional "},{"type":"codeVoice","code":"file"},{"type":"text","text":" argument:"}]},{"type":"codeListing","syntax":"swift","code":["struct Example: ParsableCommand {","    @Flag var verbose = false","    @Option var name: String","    @Argument var file: String?","","    mutating func run() throws {","        print(\"Verbose: \\(verbose), name: \\(name), file: \\(file ?? \"none\")\")","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"When calling this command, the value for "},{"type":"codeVoice","code":"--name"},{"type":"text","text":" must be given immediately after the key. If the "},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":" flag is placed in between, parsing fails with an error:"}]},{"type":"codeListing","syntax":null,"code":["% example --verbose --name Tomás","Verbose: true, name: Tomás, file: none","% example --name --verbose Tomás","Error: Missing value for '--name <name>'","Usage: example [--verbose] --name <name> [<file>]","  See 'example --help' for more information."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Parsing options as arrays is similar — only adjacent key-value pairs are recognized by default."}]},{"anchor":"Alternative-single-value-parsing-strategies","level":3,"type":"heading","text":"Alternative single-value parsing strategies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can change this behavior by providing a different parsing strategy in the "},{"type":"codeVoice","code":"@Option"},{"type":"text","text":" initializer. "},{"type":"strong","inlineContent":[{"type":"text","text":"Be careful when selecting any of the alternative parsing strategies"}]},{"type":"text","text":" — they may lead your command-line tool to have unexpected behavior for users!"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":".unconditional"},{"type":"text","text":" parsing strategy uses the immediate next input for the value of the option, even if it starts with a dash. If "},{"type":"codeVoice","code":"name"},{"type":"text","text":" were instead defined as "},{"type":"codeVoice","code":"@Option(parsing: .unconditional) var name: String"},{"type":"text","text":", the second attempt would result in "},{"type":"codeVoice","code":"\"--verbose\""},{"type":"text","text":" being read as the value of "},{"type":"codeVoice","code":"name"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":null,"code":["% example --name --verbose Tomás","Verbose: false, name: --verbose, file: Tomás"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":".scanningForValue"},{"type":"text","text":" strategy, on the other hand, looks ahead in the list of command-line inputs and uses the first un-prefixed value as the input, even if that requires skipping over other flags or options.  If "},{"type":"codeVoice","code":"name"},{"type":"text","text":" were defined as "},{"type":"codeVoice","code":"@Option(parsing: .scanningForValue) var name: String"},{"type":"text","text":", the parser would look ahead to find "},{"type":"codeVoice","code":"Tomás"},{"type":"text","text":", then pick up parsing where it left off to get the "},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":" flag:"}]},{"type":"codeListing","syntax":null,"code":["% example --name --verbose Tomás","Verbose: true, name: Tomás, file: none"]},{"anchor":"Alternative-array-parsing-strategies","level":3,"type":"heading","text":"Alternative array parsing strategies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The default strategy for parsing options as arrays is to read each value from a key-value pair. For example, this command expects zero or more input file names:"}]},{"type":"codeListing","syntax":"swift","code":["struct Example: ParsableCommand {","    @Option var file: [String] = []","    @Flag var verbose = false","","    mutating func run() throws {","        print(\"Verbose: \\(verbose), files: \\(file)\")","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"As with single values, each time the user provides the "},{"type":"codeVoice","code":"--file"},{"type":"text","text":" key, they must also provide a value:"}]},{"type":"codeListing","syntax":null,"code":["% example --verbose --file file1.swift --file file2.swift","Verbose: true, files: [\"file1.swift\", \"file2.swift\"]","% example --file --verbose file1.swift --file file2.swift","Error: Missing value for '--file <file>'","Usage: example [--file <file> ...] [--verbose]","  See 'example --help' for more information."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":".unconditionalSingleValue"},{"type":"text","text":" parsing strategy uses whatever input follows the key as its value, even if that input is dash-prefixed. If "},{"type":"codeVoice","code":"file"},{"type":"text","text":" were defined as "},{"type":"codeVoice","code":"@Option(parsing: .unconditionalSingleValue) var file: [String]"},{"type":"text","text":", then the resulting array could include strings that look like options:"}]},{"type":"codeListing","syntax":null,"code":["% example --file file1.swift --file --verbose","Verbose: false, files: [\"file1.swift\", \"--verbose\"]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":".upToNextOption"},{"type":"text","text":" parsing strategy uses the inputs that follow the option key until reaching a dash-prefixed input. If "},{"type":"codeVoice","code":"file"},{"type":"text","text":" were defined as "},{"type":"codeVoice","code":"@Option(parsing: .upToNextOption) var file: [String]"},{"type":"text","text":", then the user could specify multiple files without repeating "},{"type":"codeVoice","code":"--file"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":null,"code":["% example --file file1.swift file2.swift","Verbose: false, files: [\"file1.swift\", \"file2.swift\"]","% example --file file1.swift file2.swift --verbose","Verbose: true, files: [\"file1.swift\", \"file2.swift\"]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, the "},{"type":"codeVoice","code":".remaining"},{"type":"text","text":" parsing strategy uses all the inputs that follow the option key, regardless of their prefix. If "},{"type":"codeVoice","code":"file"},{"type":"text","text":" were defined as "},{"type":"codeVoice","code":"@Option(parsing: .remaining) var file: [String]"},{"type":"text","text":", then the user would need to specify "},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":" before the "},{"type":"codeVoice","code":"--file"},{"type":"text","text":" key for it to be recognized as a flag:"}]},{"type":"codeListing","syntax":null,"code":["% example --verbose --file file1.swift file2.swift","Verbose: true, files: [\"file1.swift\", \"file2.swift\"]","% example --file file1.swift file2.swift --verbose","Verbose: false, files: [\"file1.swift\", \"file2.swift\", \"--verbose\"]"]},{"anchor":"Alternative-positional-argument-parsing-strategies","level":3,"type":"heading","text":"Alternative positional argument parsing strategies"},{"type":"paragraph","inlineContent":[{"type":"text","text":"The default strategy for parsing arrays of positional arguments is to ignore  all dash-prefixed command-line inputs. For example, this command accepts a "},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":" flag and a list of file names as positional arguments:"}]},{"type":"codeListing","syntax":"swift","code":["struct Example: ParsableCommand {","    @Flag var verbose = false","    @Argument var files: [String] = []","","    mutating func run() throws {","        print(\"Verbose: \\(verbose), files: \\(files)\")","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"files"},{"type":"text","text":" argument array uses the default "},{"type":"codeVoice","code":".remaining"},{"type":"text","text":" parsing strategy, so it only picks up values that don’t have a prefix:"}]},{"type":"codeListing","syntax":null,"code":["% example --verbose file1.swift file2.swift","Verbose: true, files: [\"file1.swift\", \"file2.swift\"]","% example --verbose file1.swift file2.swift --other","Error: Unexpected argument '--other'","Usage: example [--verbose] [<files> ...]","  See 'example --help' for more information."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Any input after the "},{"type":"codeVoice","code":"--"},{"type":"text","text":" terminator is automatically treated as positional input, so users can provide dash-prefixed values that way even with the default configuration:"}]},{"type":"codeListing","syntax":null,"code":["% example --verbose -- file1.swift file2.swift --other","Verbose: true, files: [\"file1.swift\", \"file2.swift\", \"--other\"]"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":".unconditionalRemaining"},{"type":"text","text":" parsing strategy uses whatever input is left after parsing known options and flags, even if that input is dash-prefixed, including the terminator itself. If "},{"type":"codeVoice","code":"files"},{"type":"text","text":" were defined as "},{"type":"codeVoice","code":"@Argument(parsing: .unconditionalRemaining) var files: [String]"},{"type":"text","text":", then the resulting array would also include strings that look like options:"}]},{"type":"codeListing","syntax":null,"code":["% example --verbose file1.swift file2.swift --other","Verbose: true, files: [\"file1.swift\", \"file2.swift\", \"--other\"]","% example -- --verbose file1.swift file2.swift --other","Verbose: false, files: [\"--\", \"--verbose\", \"file1.swift\", \"file2.swift\", \"--other\"]"]}]}],"schemaVersion":{"major":0,"minor":1,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/argumentparser\/declaringarguments"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/DeclaringArguments","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Use the "},{"type":"codeVoice","code":"@Argument"},{"type":"text","text":", "},{"type":"codeVoice","code":"@Option"},{"type":"text","text":" and "},{"type":"codeVoice","code":"@Flag"},{"type":"text","text":" property wrappers to declare the command-line interface for your command."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Declaring Arguments, Options, and Flags","role":"article","modules":[{"name":"ArgumentParser"}]},"hierarchy":{"paths":[["doc:\/\/ArgumentParser\/documentation\/ArgumentParser"]]},"seeAlsoSections":[{"title":"Arguments, Options, and Flags","identifiers":["doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Argument","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Option","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Flag","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/OptionGroup","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableArguments"],"generated":true}],"references":{"doc://ArgumentParser/documentation/ArgumentParser/ParsableArguments":{"role":"symbol","title":"ParsableArguments","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ParsableArguments"}],"abstract":[{"type":"text","text":"A type that can be parsed from a program’s command-line arguments."}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableArguments","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ParsableArguments"}],"url":"\/documentation\/argumentparser\/parsablearguments"},"doc://ArgumentParser/documentation/ArgumentParser/Option":{"role":"symbol","title":"Option","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Option"}],"abstract":[{"type":"text","text":"A property wrapper that represents a command-line option."}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Option","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Option"}],"url":"\/documentation\/argumentparser\/option"},"doc://ArgumentParser/documentation/ArgumentParser/Flag":{"role":"symbol","title":"Flag","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Flag"}],"abstract":[{"type":"text","text":"A property wrapper that represents a command-line flag."}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Flag","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Flag"}],"url":"\/documentation\/argumentparser\/flag"},"doc://ArgumentParser/documentation/ArgumentParser/OptionGroup":{"role":"symbol","title":"OptionGroup","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"OptionGroup"}],"abstract":[{"type":"text","text":"A wrapper that transparently includes a parsable type."}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/OptionGroup","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"OptionGroup"}],"url":"\/documentation\/argumentparser\/optiongroup"},"doc://ArgumentParser/documentation/ArgumentParser":{"role":"collection","title":"ArgumentParser","abstract":[{"type":"text","text":"Straightforward, type-safe argument parsing for Swift."}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser","kind":"symbol","type":"topic","url":"\/documentation\/argumentparser"},"doc://ArgumentParser/documentation/ArgumentParser/EnumerableFlag":{"role":"symbol","title":"EnumerableFlag","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"EnumerableFlag"}],"abstract":[{"type":"text","text":"A type that represents the different possible flags to be used by a"},{"type":"text","text":" "},{"type":"codeVoice","code":"@Flag"},{"type":"text","text":" property."}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/EnumerableFlag","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"EnumerableFlag"}],"url":"\/documentation\/argumentparser\/enumerableflag"},"doc://ArgumentParser/documentation/ArgumentParser/Argument":{"role":"symbol","title":"Argument","fragments":[{"kind":"keyword","text":"struct"},{"kind":"text","text":" "},{"kind":"identifier","text":"Argument"}],"abstract":[{"type":"text","text":"A property wrapper that represents a positional command-line argument."}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Argument","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"Argument"}],"url":"\/documentation\/argumentparser\/argument"},"doc://ArgumentParser/documentation/ArgumentParser/Validation":{"role":"article","title":"Providing Custom Validation","abstract":[{"type":"text","text":"Provide helpful feedback to users when things go wrong."}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/Validation","kind":"article","type":"topic","url":"\/documentation\/argumentparser\/validation"}}}