{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"When command-line programs grow larger, it can be useful to divide them into a group of smaller programs, providing an interface through subcommands. Utilities such as "},{"type":"codeVoice","code":"git"},{"type":"text","text":" and the Swift package manager are able to provide varied interfaces for each of their sub-functions by implementing subcommands such as "},{"type":"codeVoice","code":"git branch"},{"type":"text","text":" or "},{"type":"codeVoice","code":"swift package init"},{"type":"text","text":"."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Generally, these subcommands each have their own configuration options, as well as options that are shared across several or all aspects of the larger program."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"You can build a program with commands and subcommands by defining multiple command types and specifying each command’s subcommands in its configuration. For example, here’s the interface of a "},{"type":"codeVoice","code":"math"},{"type":"text","text":" utility that performs operations on a series of values given on the command line."}]},{"type":"codeListing","syntax":null,"code":["% math add 10 15 7","32","% math multiply 10 15 7","1050","% math stats average 3 4 13 15 15","10.0","% math stats average --kind median 3 4 13 15 15","13.0","% math stats","OVERVIEW: Calculate descriptive statistics.","","USAGE: math stats <subcommand>","","OPTIONS:","  -h, --help              Show help information.","","SUBCOMMANDS:","  average                 Print the average of the values.","  stdev                   Print the standard deviation of the values.","  quantiles               Print the quantiles of the values (TBD).","","  See 'math help stats <subcommand>' for detailed help."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Start by defining the root "},{"type":"codeVoice","code":"Math"},{"type":"text","text":" command. You can provide a static "},{"type":"codeVoice","code":"configuration"},{"type":"text","text":" property for a command that specifies its subcommands and a default subcommand, if any."}]},{"type":"codeListing","syntax":"swift","code":["struct Math: ParsableCommand {","    static var configuration = CommandConfiguration(","        abstract: \"A utility for performing maths.\",","        subcommands: [Add.self, Multiply.self, Statistics.self],","        defaultSubcommand: Add.self)","}"]},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"Math"},{"type":"text","text":" lists its three subcommands by their types; we’ll see the definitions of "},{"type":"codeVoice","code":"Add"},{"type":"text","text":", "},{"type":"codeVoice","code":"Multiply"},{"type":"text","text":", and "},{"type":"codeVoice","code":"Statistics"},{"type":"text","text":" below. "},{"type":"codeVoice","code":"Add"},{"type":"text","text":" is also given as a default subcommand — this means that it is selected if a user leaves out a subcommand name:"}]},{"type":"codeListing","syntax":null,"code":["% math 10 15 7","32"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next, define a "},{"type":"codeVoice","code":"ParsableArguments"},{"type":"text","text":" type with properties that will be shared across multiple subcommands. Types that conform to "},{"type":"codeVoice","code":"ParsableArguments"},{"type":"text","text":" can be parsed from command-line arguments, but don’t provide any execution through a "},{"type":"codeVoice","code":"run()"},{"type":"text","text":" method."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In this case, the "},{"type":"codeVoice","code":"Options"},{"type":"text","text":" type accepts a "},{"type":"codeVoice","code":"--hexadecimal-output"},{"type":"text","text":" flag and expects a list of integers."}]},{"type":"codeListing","syntax":"swift","code":["struct Options: ParsableArguments {","    @Flag(name: [.long, .customShort(\"x\")], help: \"Use hexadecimal notation for the result.\")","    var hexadecimalOutput = false","","    @Argument(help: \"A group of integers to operate on.\")","    var values: [Int]","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"It’s time to define our first two subcommands: "},{"type":"codeVoice","code":"Add"},{"type":"text","text":" and "},{"type":"codeVoice","code":"Multiply"},{"type":"text","text":". Both of these subcommands include the arguments defined in the "},{"type":"codeVoice","code":"Options"},{"type":"text","text":" type by denoting that property with the "},{"type":"codeVoice","code":"@OptionGroup"},{"type":"text","text":" property wrapper. "},{"type":"codeVoice","code":"@OptionGroup"},{"type":"text","text":" doesn’t define any new arguments for a command; instead, it splats in the arguments defined by another "},{"type":"codeVoice","code":"ParsableArguments"},{"type":"text","text":" type."}]},{"type":"codeListing","syntax":"swift","code":["extension Math {","    struct Add: ParsableCommand {","        static var configuration","            = CommandConfiguration(abstract: \"Print the sum of the values.\")","","        @OptionGroup var options: Math.Options","","        mutating func run() {","            let result = options.values.reduce(0, +)","            print(format(result: result, usingHex: options.hexadecimalOutput))","        }","    }","","    struct Multiply: ParsableCommand {","        static var configuration","            = CommandConfiguration(abstract: \"Print the product of the values.\")","","        @OptionGroup var options: Math.Options","","        mutating func run() {","            let result = options.values.reduce(1, *)","            print(format(result: result, usingHex: options.hexadecimalOutput))","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next, we’ll define "},{"type":"codeVoice","code":"Statistics"},{"type":"text","text":", the third subcommand of "},{"type":"codeVoice","code":"Math"},{"type":"text","text":". The "},{"type":"codeVoice","code":"Statistics"},{"type":"text","text":" command specifies a custom command name ("},{"type":"codeVoice","code":"stats"},{"type":"text","text":") in its configuration, overriding the default derived from the type name ("},{"type":"codeVoice","code":"statistics"},{"type":"text","text":"). It also declares two additional subcommands, meaning that it acts as a forked branch in the command tree, and not a leaf."}]},{"type":"codeListing","syntax":"swift","code":["extension Math {","    struct Statistics: ParsableCommand {","        static var configuration = CommandConfiguration(","            commandName: \"stats\",","            abstract: \"Calculate descriptive statistics.\",","            subcommands: [Average.self, StandardDeviation.self])","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s finish our subcommands with the "},{"type":"codeVoice","code":"Average"},{"type":"text","text":" and "},{"type":"codeVoice","code":"StandardDeviation"},{"type":"text","text":" types. Each of them has slightly different arguments, so they don’t use the "},{"type":"codeVoice","code":"Options"},{"type":"text","text":" type defined above. Each subcommand is ultimately independent and can specify a combination of shared and unique arguments."}]},{"type":"codeListing","syntax":"swift","code":["extension Math.Statistics {","    struct Average: ParsableCommand {","        static var configuration = CommandConfiguration(","            abstract: \"Print the average of the values.\")","","        enum Kind: String, ExpressibleByArgument {","            case mean, median, mode","        }","","        @Option(help: \"The kind of average to provide.\")","        var kind: Kind = .mean","","        @Argument(help: \"A group of floating-point values to operate on.\")","        var values: [Double] = []","","        func calculateMean() -> Double { ... }","        func calculateMedian() -> Double { ... }","        func calculateMode() -> [Double] { ... }","","        mutating func run() {","            switch kind {","            case .mean:","                print(calculateMean())","            case .median:","                print(calculateMedian())","            case .mode:","                let result = calculateMode()","                    .map(String.init(describing:))","                    .joined(separator: \" \")","                print(result)","            }","        }","    }","","    struct StandardDeviation: ParsableCommand {","        static var configuration = CommandConfiguration(","            commandName: \"stdev\",","            abstract: \"Print the standard deviation of the values.\")","","        @Argument(help: \"A group of floating-point values to operate on.\")","        var values: [Double] = []","","        mutating func run() {","            if values.isEmpty {","                print(0.0)","            } else {","                let sum = values.reduce(0, +)","                let mean = sum \/ Double(values.count)","                let squaredErrors = values","                    .map { $0 - mean }","                    .map { $0 * $0 }","                let variance = squaredErrors.reduce(0, +)","                let result = variance.squareRoot()","                print(result)","            }","        }","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Last but not least, we kick off parsing and execution with a call to the static "},{"type":"codeVoice","code":"main"},{"type":"text","text":" method on the type at the root of our command tree. The call to main parses the command-line arguments, determines whether a subcommand was selected, and then instantiates and calls the "},{"type":"codeVoice","code":"run()"},{"type":"text","text":" method on that particular subcommand."}]},{"type":"codeListing","syntax":"swift","code":["Math.main()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"That’s it for this doubly-nested "},{"type":"codeVoice","code":"math"},{"type":"text","text":" command! This example is also provided as a part of the "},{"type":"codeVoice","code":"swift-argument-parser"},{"type":"text","text":" repository, so you can see it all together and experiment with it "},{"type":"reference","isActive":true,"identifier":"https:\/\/github.com\/apple\/swift-argument-parser\/blob\/main\/Examples\/math\/main.swift"},{"type":"text","text":"."}]}]}],"schemaVersion":{"major":0,"minor":1,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/argumentparser\/commandsandsubcommands"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/CommandsAndSubcommands","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Break complex command-line tools into a tree of subcommands."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Defining Commands and Subcommands","role":"article","modules":[{"name":"ArgumentParser"}]},"hierarchy":{"paths":[["doc:\/\/ArgumentParser\/documentation\/ArgumentParser"]]},"seeAlsoSections":[{"title":"Essentials","identifiers":["doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/GettingStarted","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand"],"generated":true}],"references":{"https://github.com/apple/swift-argument-parser/blob/main/Examples/math/main.swift":{"title":"here","titleInlineContent":[{"type":"text","text":"here"}],"type":"link","identifier":"https:\/\/github.com\/apple\/swift-argument-parser\/blob\/main\/Examples\/math\/main.swift","url":"https:\/\/github.com\/apple\/swift-argument-parser\/blob\/main\/Examples\/math\/main.swift"},"doc://ArgumentParser/documentation/ArgumentParser/ParsableCommand":{"role":"symbol","title":"ParsableCommand","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ParsableCommand"}],"abstract":[{"type":"text","text":"A type that can be executed as part of a nested tree of commands."}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ParsableCommand"}],"url":"\/documentation\/argumentparser\/parsablecommand"},"doc://ArgumentParser/documentation/ArgumentParser":{"role":"collection","title":"ArgumentParser","abstract":[{"type":"text","text":"Straightforward, type-safe argument parsing for Swift."}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser","kind":"symbol","type":"topic","url":"\/documentation\/argumentparser"},"doc://ArgumentParser/documentation/ArgumentParser/GettingStarted":{"role":"article","title":"Getting Started with ArgumentParser","abstract":[{"type":"text","text":"Learn to set up and customize a simple command-line tool."}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/GettingStarted","kind":"article","type":"topic","url":"\/documentation\/argumentparser\/gettingstarted"}}}