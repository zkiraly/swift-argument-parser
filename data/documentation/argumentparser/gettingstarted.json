{"primaryContentSections":[{"kind":"content","content":[{"anchor":"Overview","level":2,"type":"heading","text":"Overview"},{"type":"paragraph","inlineContent":[{"type":"text","text":"This guide walks through building an example command. You’ll learn about the different tools that "},{"type":"codeVoice","code":"ArgumentParser"},{"type":"text","text":" provides for defining a command’s options, customizing the interface, and providing help text for your user."}]},{"anchor":"Adding-ArgumentParser-as-a-Dependency","level":2,"type":"heading","text":"Adding ArgumentParser as a Dependency"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s write a tool called "},{"type":"codeVoice","code":"count"},{"type":"text","text":" that reads an input file, counts the words, and writes the result to an output file."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"First, we need to add "},{"type":"codeVoice","code":"swift-argument-parser"},{"type":"text","text":" as a dependency to our package,"},{"type":"text","text":" "},{"type":"text","text":"and then include "},{"type":"codeVoice","code":"\"ArgumentParser\""},{"type":"text","text":" as a dependency for our executable target."},{"type":"text","text":" "},{"type":"text","text":"Our “Package.swift” file ends up looking like this:"}]},{"type":"codeListing","syntax":"swift","code":["\/\/ swift-tools-version:5.2","import PackageDescription","","let package = Package(","    name: \"random\",","    dependencies: [","        .package(url: \"https:\/\/github.com\/apple\/swift-argument-parser.git\", from: \"0.4.0\"),","    ],","    targets: [","        .target(","            name: \"count\",","            dependencies: [.product(name: \"ArgumentParser\", package: \"swift-argument-parser\")]),","    ]",")"]},{"type":"aside","style":"note","content":[{"type":"paragraph","inlineContent":[{"type":"strong","inlineContent":[{"type":"text","text":"Note:"}]},{"type":"text","text":" To read more about creating and configuring packages using Swift Package Manager, see "},{"type":"reference","isActive":true,"identifier":"https:\/\/swift.org\/getting-started\/#using-the-package-manager"},{"type":"text","text":"."}]}]},{"anchor":"Building-Our-First-Command","level":2,"type":"heading","text":"Building Our First Command"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Once we’ve built the "},{"type":"codeVoice","code":"count"},{"type":"text","text":" tool, we’ll be able to run it like this:"}]},{"type":"codeListing","syntax":null,"code":["% count readme.md readme.counts","Counting words in 'readme.md' and writing the result into 'readme.counts'."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We’ll define the initial version of the command as a type that conforms to the "},{"type":"codeVoice","code":"ParsableCommand"},{"type":"text","text":" protocol:"}]},{"type":"codeListing","syntax":"swift","code":["import ArgumentParser","","struct Count: ParsableCommand {","    @Argument var inputFile: String","    @Argument var outputFile: String","    ","    mutating func run() throws {","        print(\"\"\"","            Counting words in '\\(inputFile)' \\","            and writing the result into '\\(outputFile)'.","            \"\"\")","            ","        \/\/ Read 'inputFile', count the words, and save to 'outputFile'.","    }","}","","Count.main()"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"In the code above, the "},{"type":"codeVoice","code":"inputFile"},{"type":"text","text":" and "},{"type":"codeVoice","code":"outputFile"},{"type":"text","text":" properties use the "},{"type":"codeVoice","code":"@Argument"},{"type":"text","text":" property wrapper. "},{"type":"codeVoice","code":"ArgumentParser"},{"type":"text","text":" uses this wrapper to denote a positional command-line input — because "},{"type":"codeVoice","code":"inputFile"},{"type":"text","text":" is specified first in the "},{"type":"codeVoice","code":"Count"},{"type":"text","text":" type, it’s the first value read from the command line, and "},{"type":"codeVoice","code":"outputFile"},{"type":"text","text":" is read second."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We’ve implemented the command’s logic in its "},{"type":"codeVoice","code":"run()"},{"type":"text","text":" method. Here, we’re printing out a message confirming the names of the files the user gave. (You can find a full implementation of the completed command at the end of this guide.)"}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Finally, you tell the parser to execute the "},{"type":"codeVoice","code":"Count"},{"type":"text","text":" command by calling its static "},{"type":"codeVoice","code":"main()"},{"type":"text","text":" method. This method parses the command-line arguments, verifies that they match up with what we’ve defined in "},{"type":"codeVoice","code":"Count"},{"type":"text","text":", and either calls the "},{"type":"codeVoice","code":"run()"},{"type":"text","text":" method or exits with a helpful message."}]},{"anchor":"Working-with-Named-Options","level":2,"type":"heading","text":"Working with Named Options"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Our "},{"type":"codeVoice","code":"count"},{"type":"text","text":" tool may have a usability problem — it’s not immediately clear whether a user should provide the input file first, or the output file. Instead of using positional arguments for our two inputs, let’s specify that they should be labeled options:"}]},{"type":"codeListing","syntax":null,"code":["% count --input-file readme.md --output-file readme.counts","Counting words in 'readme.md' and writing the result into 'readme.counts'."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"We do this by using the "},{"type":"codeVoice","code":"@Option"},{"type":"text","text":" property wrapper instead of "},{"type":"codeVoice","code":"@Argument"},{"type":"text","text":":"}]},{"type":"codeListing","syntax":"swift","code":["struct Count: ParsableCommand {","    @Option var inputFile: String","    @Option var outputFile: String","    ","    mutating func run() throws {","        print(\"\"\"","            Counting words in '\\(inputFile)' \\","            and writing the result into '\\(outputFile)'.","            \"\"\")","            ","        \/\/ Read 'inputFile', count the words, and save to 'outputFile'.","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"@Option"},{"type":"text","text":" property wrapper denotes a command-line input that looks like "},{"type":"codeVoice","code":"--name <value>"},{"type":"text","text":", deriving its name from the name of your property."}]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This interface has a trade-off for the users of our "},{"type":"codeVoice","code":"count"},{"type":"text","text":" tool: With "},{"type":"codeVoice","code":"@Argument"},{"type":"text","text":", users don’t need to type as much, but they have to remember whether to provide the input file or the output file first. Using "},{"type":"codeVoice","code":"@Option"},{"type":"text","text":" makes the user type a little more, but the distinction between values is explicit. Options are order-independent, as well, so the user can name the input and output files in either order:"}]},{"type":"codeListing","syntax":null,"code":["% count --output-file readme.counts --input-file readme.md","Counting words in 'readme.md' and writing the result into 'readme.counts'."]},{"anchor":"Adding-a-Flag","level":2,"type":"heading","text":"Adding a Flag"},{"type":"paragraph","inlineContent":[{"type":"text","text":"Next, we want to add a "},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":" flag to our tool, and only print the message if the user specifies that option:"}]},{"type":"codeListing","syntax":null,"code":["% count --input-file readme.md --output-file readme.counts","(no output)","% count --verbose --input-file readme.md --output-file readme.counts","Counting words in 'readme.md' and writing the result into 'readme.counts'."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Let’s change our "},{"type":"codeVoice","code":"Count"},{"type":"text","text":" type to look like this:"}]},{"type":"codeListing","syntax":"swift","code":["struct Count: ParsableCommand {","    @Option var inputFile: String","    @Option var outputFile: String","    @Flag var verbose = false","    ","    mutating func run() throws {","        if verbose {","            print(\"\"\"","                Counting words in '\\(inputFile)' \\","                and writing the result into '\\(outputFile)'.","                \"\"\")","        }"," ","        \/\/ Read 'inputFile', count the words, and save to 'outputFile'.","    }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The "},{"type":"codeVoice","code":"@Flag"},{"type":"text","text":" property wrapper denotes a command-line input that looks like "},{"type":"codeVoice","code":"--name"},{"type":"text","text":", deriving its name from the name of your property. Flags are most frequently used for Boolean values, like the "},{"type":"codeVoice","code":"verbose"},{"type":"text","text":" property here."}]},{"anchor":"Using-Custom-Names","level":2,"type":"heading","text":"Using Custom Names"},{"type":"paragraph","inlineContent":[{"type":"text","text":"We can customize the names of our options and add an alternative to the "},{"type":"codeVoice","code":"verbose"},{"type":"text","text":" flag so that users can specify "},{"type":"codeVoice","code":"-v"},{"type":"text","text":" instead of "},{"type":"codeVoice","code":"--verbose"},{"type":"text","text":". The new interface will look like this:"}]},{"type":"codeListing","syntax":null,"code":["% count -v -i readme.md -o readme.counts","Counting words in 'readme.md' and writing the result into 'readme.counts'.","% count --input readme.md --output readme.counts -v","Counting words in 'readme.md' and writing the result into 'readme.counts'.","% count -o readme.counts -i readme.md --verbose","Counting words in 'readme.md' and writing the result into 'readme.counts'."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"Customize the input names by passing "},{"type":"codeVoice","code":"name"},{"type":"text","text":" parameters to the "},{"type":"codeVoice","code":"@Option"},{"type":"text","text":" and "},{"type":"codeVoice","code":"@Flag"},{"type":"text","text":" initializers:"}]},{"type":"codeListing","syntax":"swift","code":["struct Count: ParsableCommand {","    @Option(name: [.short, .customLong(\"input\")])","    var inputFile: String","","    @Option(name: [.short, .customLong(\"output\")])","    var outputFile: String","","    @Flag(name: .shortAndLong)","    var verbose = false","    ","    mutating func run() throws { ... }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The default name specification is "},{"type":"codeVoice","code":".long"},{"type":"text","text":", which uses a property’s name with a two-dash prefix. "},{"type":"codeVoice","code":".short"},{"type":"text","text":" uses only the first letter of a property’s name with a single-dash prefix, and allows combining groups of short options. You can specify custom short and long names with the "},{"type":"codeVoice","code":".customShort(_:)"},{"type":"text","text":" and "},{"type":"codeVoice","code":".customLong(_:)"},{"type":"text","text":" methods, respectively, or use the combined "},{"type":"codeVoice","code":".shortAndLong"},{"type":"text","text":" property to specify the common case of both the short and long derived names."}]},{"anchor":"Providing-Help","level":2,"type":"heading","text":"Providing Help"},{"type":"paragraph","inlineContent":[{"type":"codeVoice","code":"ArgumentParser"},{"type":"text","text":" automatically generates help for any command when a user provides the "},{"type":"codeVoice","code":"-h"},{"type":"text","text":" or "},{"type":"codeVoice","code":"--help"},{"type":"text","text":" flags:"}]},{"type":"codeListing","syntax":null,"code":["% count --help","USAGE: count --input <input> --output <output> [--verbose]","","OPTIONS:","  -i, --input <input>      ","  -o, --output <output>    ","  -v, --verbose            ","  -h, --help              Show help information."]},{"type":"paragraph","inlineContent":[{"type":"text","text":"This is a great start — you can see that all the custom names are visible, and the help shows that values are expected for the "},{"type":"codeVoice","code":"--input"},{"type":"text","text":" and "},{"type":"codeVoice","code":"--output"},{"type":"text","text":" options. However, our custom options and flag don’t have any descriptive text. Let’s add that now by passing string literals as the "},{"type":"codeVoice","code":"help"},{"type":"text","text":" parameter:"}]},{"type":"codeListing","syntax":"swift","code":["struct Count: ParsableCommand {","    @Option(name: [.short, .customLong(\"input\")], help: \"A file to read.\")","    var inputFile: String","","    @Option(name: [.short, .customLong(\"output\")], help: \"A file to save word counts to.\")","    var outputFile: String","","    @Flag(name: .shortAndLong, help: \"Print status updates while counting.\")","    var verbose = false","","    mutating func run() throws { ... }","}"]},{"type":"paragraph","inlineContent":[{"type":"text","text":"The help screen now includes descriptions for each parameter:"}]},{"type":"codeListing","syntax":null,"code":["% count -h","USAGE: count --input <input> --output <output> [--verbose]","","OPTIONS:","  -i, --input <input>     A file to read. ","  -o, --output <output>   A file to save word counts to. ","  -v, --verbose           Print status updates while counting. ","  -h, --help              Show help information.",""]},{"anchor":"The-Complete-Utility","level":2,"type":"heading","text":"The Complete Utility"},{"type":"paragraph","inlineContent":[{"type":"text","text":"As promised, here’s the complete "},{"type":"codeVoice","code":"count"},{"type":"text","text":" command, for your experimentation:"}]},{"type":"codeListing","syntax":"swift","code":["import ArgumentParser","import Foundation","","struct Count: ParsableCommand {","    static let configuration = CommandConfiguration(abstract: \"Word counter.\")","    ","    @Option(name: [.short, .customLong(\"input\")], help: \"A file to read.\")","    var inputFile: String","","    @Option(name: [.short, .customLong(\"output\")], help: \"A file to save word counts to.\")","    var outputFile: String","","    @Flag(name: .shortAndLong, help: \"Print status updates while counting.\")","    var verbose = false","","    mutating func run() throws {","        if verbose {","            print(\"\"\"","                Counting words in '\\(inputFile)' \\","                and writing the result into '\\(outputFile)'.","                \"\"\")","        }"," ","        guard let input = try? String(contentsOfFile: inputFile) else {","            throw RuntimeError(\"Couldn't read from '\\(inputFile)'!\")","        }","        ","        let words = input.components(separatedBy: .whitespacesAndNewlines)","            .map { word in","                word.trimmingCharacters(in: CharacterSet.alphanumerics.inverted)","                    .lowercased()","            }","            .compactMap { word in word.isEmpty ? nil : word }","        ","        let counts = Dictionary(grouping: words, by: { $0 })","            .mapValues { $0.count }","            .sorted(by: { $0.value > $1.value })","        ","        if verbose {","            print(\"Found \\(counts.count) words.\")","        }","        ","        let output = counts.map { word, count in \"\\(word): \\(count)\" }","            .joined(separator: \"\\n\")","        ","        guard let _ = try? output.write(toFile: outputFile, atomically: true, encoding: .utf8) else {","            throw RuntimeError(\"Couldn't write to '\\(outputFile)'!\")","        }","    }","}","","struct RuntimeError: Error, CustomStringConvertible {","    var description: String","    ","    init(_ description: String) {","        self.description = description","    }","}","","Count.main()"]}]}],"schemaVersion":{"major":0,"minor":1,"patch":0},"sections":[],"variants":[{"paths":["\/documentation\/argumentparser\/gettingstarted"],"traits":[{"interfaceLanguage":"swift"}]}],"identifier":{"url":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/GettingStarted","interfaceLanguage":"swift"},"abstract":[{"type":"text","text":"Learn to set up and customize a simple command-line tool."}],"kind":"article","metadata":{"roleHeading":"Article","title":"Getting Started with ArgumentParser","role":"article","modules":[{"name":"ArgumentParser"}]},"hierarchy":{"paths":[["doc:\/\/ArgumentParser\/documentation\/ArgumentParser"]]},"seeAlsoSections":[{"title":"Essentials","identifiers":["doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/CommandsAndSubcommands","doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand"],"generated":true}],"references":{"doc://ArgumentParser/documentation/ArgumentParser":{"role":"collection","title":"ArgumentParser","abstract":[{"type":"text","text":"Straightforward, type-safe argument parsing for Swift."}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser","kind":"symbol","type":"topic","url":"\/documentation\/argumentparser"},"doc://ArgumentParser/documentation/ArgumentParser/CommandsAndSubcommands":{"role":"article","title":"Defining Commands and Subcommands","abstract":[{"type":"text","text":"Break complex command-line tools into a tree of subcommands."}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/CommandsAndSubcommands","kind":"article","type":"topic","url":"\/documentation\/argumentparser\/commandsandsubcommands"},"https://swift.org/getting-started/#using-the-package-manager":{"title":"Using the Package Manager","titleInlineContent":[{"type":"text","text":"Using the Package Manager"}],"type":"link","identifier":"https:\/\/swift.org\/getting-started\/#using-the-package-manager","url":"https:\/\/swift.org\/getting-started\/#using-the-package-manager"},"doc://ArgumentParser/documentation/ArgumentParser/ParsableCommand":{"role":"symbol","title":"ParsableCommand","fragments":[{"kind":"keyword","text":"protocol"},{"kind":"text","text":" "},{"kind":"identifier","text":"ParsableCommand"}],"abstract":[{"type":"text","text":"A type that can be executed as part of a nested tree of commands."}],"identifier":"doc:\/\/ArgumentParser\/documentation\/ArgumentParser\/ParsableCommand","kind":"symbol","type":"topic","navigatorTitle":[{"kind":"identifier","text":"ParsableCommand"}],"url":"\/documentation\/argumentparser\/parsablecommand"}}}